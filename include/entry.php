<?php

/** 
 * Quick summary of usage:
 * 
 * Entry::find('*.post')
 * Entry::load('test.post')
 * Entry::save('test.post', array('Header' => 'value'), 'Some multiline content')
 * 
 * $entry->title
 * $entry->tags
 * $entry->tags_as_list
 * $entry->content
 * $entry->raw_content
 * $entry->path
 * $entry->public_path
 * $entry->public_path_for('figure.png')
 */

/**
 * This function registers a new processor for usage in the entries. The string specified in
 * `$name` can then be used in the `Processors` header to build a content processing pipeline
 * for the entry.  If the `Processors` header of an entry contains the specified name (converted
 * to lower case) the handler (a closure) is called with the raw content and the entry itself as
 * an argument.
	 * 
	 * The return value of the handler is then used as the processed entry content.
 * 
 * Each processor handler gets the raw content to process and the entry object itself.
 * 
 * Example for adding a markdown processor:
 * 
 * 	Entry::processor('markdown', function($raw_content, $entry){
 * 		return Markdown($raw_content);
 *	});
 */

/**

# Entry configuration

## Processors

Processors are small functions that process the content of an entry in some form. For example the text of
and entry might be passed through Markdown to get nice HTML code for a blog or website. After that the
next processor may be searching for special simily codes and replace them with image tags. Processors
can for a pipeline: the output of one processor is the input for the next processor. In each entry the
`Processors` header can be a list of processors the content is passed through.

	Entry::processor('markdown', function($content, $entry){
		return Markdown($content);
	});
	
	Entry::processor('toc', function($content, $entry){
		// code to generate a table of contents out of HTML (since Markdown outputs HTML)
	});

These processors can than be used in an entry:

	Processors: markdown, toc
	
	# Hello
	
	This is a `test`.

When the entry is loaded and it's `content` property is accessed the original content of the entry is send
through the `markdown` processor. It will generate some nice HTML code for the heading, paragraph and
code. After that the HTML output of the `markdown` processor is send to the `toc` processor which generates
a table of contents out of the HTML code and adds it to the output. Processors can be chained in any way as
long as the user makes sure the input and output format match. To access the unprocessed content use the
`raw_content` property.


## Routes

An entry is often associated with some kind of public identifier (URL, path, ID, whatever). To allow to use
these identifyers directly the `Entry` class can be configured with "routes". These routes translate the
identifiers to file system paths ("in routes", routes showing the way towards an entry) and the other way
around ("out routes", routes that construct the public identifier for an entry).

Once an in route is defined entries can be loaded or saved with the `load_by_route()` and `save_by_route()`
functions. The `id` property of an entry will contain the public identifier as long as an out route for that
entry type is set or a fallback out route (with `$type` set to `null`) is set.

	Entry::route_in(function($url){
		if ( preg_match('#^/data(/.+)$#i', $url, $matches) )
			return $_CONFIG['data_dir'] . $matches[1];
	});



Entry::processor($name, $handler)

Entry::route_in($route)
Entry::route_out($type, $route)

// Route based functions (use in routes to convert ids to paths)
Entry::load_from_id($id)
Entry::save_to_id($id, $headers, $content)

// Path based functions
Entry::find($glob_pattern)
Entry::load($path)
Entry::save($path, $headers, $content)

// Memory functions
Entry::load_from_string($raw_file_content)
Entry::save_to_string($headers, $content)

// Instance interface
$entry->headers  // array of all headers (lowercase and trimmed)
$entry->title  // all headers are available as properties
$entry->content  // processed content
$entry->raw_content  // unprocessed text content
$entry->path  // real file system path of the entry file
$entry->id  // id (URL, path, ...) for this entry generated by an out route)
$entry->original_id  // the id the entry was loaded from

$entry->url  // public URL for this entry generated by the out router
$entry->url_for('figure.png')  // public URL for a file that belongs to the entry

*/

class Entry
{
	// Configuration data
	private static $processors = array();
	private static $in_routes = array();
	private static $out_routes = array();
	
	// The file system path the entry has been read from or `null` if it was
	// read from a string
	private $path;
	// The type is the file extention of the loaded entry. Out routes are usually
	// associated with one type.
	private $type;
	// The id the matching out route calculated for this entry.
	private $id;
	// The id the entry has been loaded from or `null` if it has been loaded
	// from a file or string
	private $original_id;
	// Associative array containing the headers
	private $headers;
	// Processed content (raw content piped through the processors)
	private $content;
	// Raw content as read from the entry
	private $raw_content;
	
	//private static $routers = array();
	
	
	//
	// Configuration functions
	//
	
	/**
	 * You can use this function to register a new processor for the content text
	 * of entries. If the "processor" header of the entry is the specified name (converted
	 * to lower case) the handler (a closure) is called with the raw content as argument.
	 * 
	 * The return value of the handler is then used as the processed entry content.
	 * 
	 * Example adding a markdown processor:
	 * 
	 * 	Entry::add_processor('markdown', function($raw_content, $entry){
	 * 		return Markdown($raw_content);
	 * 	});
	 * 
	 * This function returns `true` if the processor has been added or `false` if `$handler`
	 * is not callable.
	 */
	static function processor($name, $handler)
	{
		if ( is_callable($handler) ) {
			self::$processors[$name] = $handler;
			return true;
		}
		
		return false;
	}
	
	/**
	 * Adds an in route to the `Entry` class. These routes are used by the `load_from_id()`
	 * and `save_to_id()` functions to translate ids to file system paths. If you add multple
	 * in routes they are tried in the order they are added. The first one added having
	 * the highes priority.
	 * 
	 * A route is a function that gets the id as a parameter and should return the file system
	 * path the id translates to as string. If an in route function returns `null` the next in route
	 * is tried. If an in route function returns `false` the id is regarded as invalid and the
	 * translation is aborted. If no in route returned a path or the translation is aborted the
	 * regarding `load_from_id()` and `save_to_id()` functions will also return `false`.
	 */
	static function route_in($route)
	{
		if ( is_callable($route) ) {
			self::$in_routes[] = $route;
			return true;
		}
		
		return false;
	}
	
	static function route_out($type, $route)
	{
		if ( is_callable($route) ) {
			self::$out_routes[$type] = $route;
			return true;
		}
		
		return false;
	}
	
	
	//
	// Route based load and save functions
	//
	
	/**
	 * Loads an entry from the specified `$id`. Basically the same as `load()` but first translates
  	 * the id into a file system path with the configured in routes. If no in routes are configured
	 * or the id is invalid `false` is returned. See `load_from_string()` for an explanation of the
	 * `$clean_up_headers` parameter.
	 * 
	 * The id the entry has been loaded from is available as the `$id` property. The `$path` property
	 * contains the file system path the id was translated to and from where the entry has been
	 * loaded.
	 */
	static function load_from_id($id, $clean_up_headers = true)
	{
		$path = self::translate_id_to_path($id);
		if ( ! $path )
			return false;
		
		$entry = self::load($path, $clean_up_headers);
		$entry->original_id = $id;
		return $entry;
	}
	
	/**
	 * Saves an entry to the specified `$id`. Basically the same as `save()` but first translates
	 * the id into a file system path with the configured in routes. If no in routes are configured
	 * or the id is invalid `false` is returned.
	 */
	static function save_to_id($id, $headers, $content)
	{
		$path = self::translate_id_to_path($id);
		return $path ? self::save($path) : false;
	}
	
	/**
	 * Translates the specified `$id` to a file system path that can be used with `load()` or
	 * `save()`. How the in routes are used for the translation is explained in the documentation
	 * of the `route_in()` function.
	 */
	static function translate_id_to_path($id)
	{
		foreach(self::$in_routes as $route)
		{
			$path = $route($id);
			if ($path === false)
				return false;
			if ($path !== null )
				return $path;
		}
		
		return false;
	}
	
	
	//
	// File based load and save functions
	//
	
	/**
	 * Loads the entity files matching the specified glob pattern.
	 * 
	 * Options:
	 * 	limit: The max. number of entities to load.
	 * 	sort_with: The sort function used for the files. You can use 'rsort' (newest first) or 'sort' (oldest first).
	 * 	prepare_for_caching: If set to true every found entry will be prepared for caching by calculating everything.
	 * 	clean_up_headers: If set to `false` the header name and values will not be cleand up during loading. See `load_from_string()` for details.
	 */
	static function find($glob_pattern, $options = array())
	{
		$options = array_merge(array('sort_with' => 'rsort', 'prepare_for_caching' => false, 'clean_up_headers' => true), $options);
		
		$entries = array();
		$entry_files = glob($glob_pattern);
		$options['sort_with']($entry_files);
		
		if ( array_key_exists('limit', $options) )
			$entry_files = array_slice($entry_files, 0, $options['limit']);
		
		foreach($entry_files as $file)
		{
			$entry = self::load($file, $options['clean_up_headers']);
			if ($options['prepare_for_caching'])
				$entry->prepare_for_caching();
			
			$entries[] = $entry;
		}
		
		return $entries;
	}
	
	/**
	 * Loads the specified file and returns an entry object.
	 */
	static function load($path, $clean_up_headers = true)
	{
		if ( ! file_exists($path) )
			return false;
		
		$data = @file_get_contents($path);
		if ( ! $data )
			return false;
		
		return self::load_from_string($data, $path, $clean_up_headers);
	}
	
	/**
	 * Saves an entry at the specified path. $headers is expected to be an array of
	 * header field name and header field value pairs. $content is the actual content
	 * of the entry.
	 * 
	 * Example:
	 * 
	 * 	Entry::save('example.post', array('Name' => 'Example post'), 'Example content');
	 */
	static function save($path, $headers, $content = null)
	{
		return @file_put_contents($path, self::save_to_string($headers, $content));
	}
	
	
	//
	// Memory based load and save functions
	//
	
	/**
	 * Takes the text representation of the entry in `$entry_data` and creates an
	 * `Entry` object out of it.
	 * 
	 * Usually the headers of an entry receive some special treatment. The names
	 * are trimmed and converted to lower case. This makes sure you can access
	 * each header as a property without regardless of case. The header values are
	 * trimmed, too. Since the text representation of entries should also be editable
	 * by humans this eliminates some unintended white spaces. However this cean
	 * up procedure makes it impossible to reconstruct an entry in its original form.
	 * Therefore you can disable it by setting the `$clean_up_headers` parameter
	 * to `false`.
	 * 
	 * In that mode you have to take case sensitivity of header names into account.
	 * The entry is disassembled without manipulation and therefore perfect to
	 * reconstruct the text representation of the entry again after a slight manipulation
	 * (e.g. adding a  new header). This does not destroy any formatting (e.g. with
	 * whitespaces) the user applied.
	 */
	static function load_from_string($entry_data, $path = null, $clean_up_headers = true)
	{
		@list($head, $content) = explode("\n\n", $entry_data, 2);
		$headers = empty($head) ? array() : self::parse_head($head, $clean_up_headers);
		
		return new self($headers, $content, $path);
	}
	
	/**
	 * Parses the specified head text of an entity and returns an array with the headers.
	 * 
	 * To allow consistant access header names are usually trimmed and converted to lower
	 * case. Header values are just trimmed. Set the `$clean_up` parameter to `false` to skip
	 * this post processing. This is useful if you want to update a part of an entry and leave
	 * it as original as possible.
	 */
	static function parse_head($head, $clean_up = true)
	{
		$headers = array();
		foreach( explode("\n", $head) as $header_line )
		{
			list($name, $value) = explode(': ', $header_line, 2);
			if ($clean_up)
			{
				$name = strtolower(trim($name));
				$value = trim($value);
			}
			
			if ( !array_key_exists($name, $headers) )
				$headers[$name] = $value;
			else
				if (is_array($headers[$name]))
					array_push($headers[$name], $value);
				else
					$headers[$name] = array($headers[$name], $value);
		}
		
		return $headers;
	}
	
	/**
	 * Creates a text representation of the specified entry. `$headers` is expected to be an
	 * array of header field name and header field value pairs. `$content` is the actual content
	 * of the entry.
	 * 
	 * The text representation is returned as string.
	 * 
	 * 	$data = Entry::save_to_string(array('Name' => 'Example post'), 'Example content');
	 */
	static function save_to_string($headers, $content = null)
	{
		$head = join("\n", array_map(function($name, $value){
			$sanitized_name = strtr($name, "\n:", '  ');
			if ( is_array($value) )
				return join("\n", array_map(function($line){
					$sanitized_name. ': ' . str_replace("\n", ' ', $line);
				}, $value));
			else
				return $sanitized_name . ': ' . str_replace("\n", ' ', $value);
		}, array_keys($headers), $headers) );
		
		return empty($content) ? $head : $head . "\n\n" . $content;
	}
	
	
	

	
	function __construct($headers, $content, $path = null)
	{
		$this->headers = $headers;
		$this->raw_content = $content;
		$this->path = $path;
		$this->type = empty($path) ? null : pathinfo($path, PATHINFO_EXTENSION);
		$this->id = self::translate_path_to_id($path, $this);
	}
	
	static function translate_path_to_id($path, $entry = null)
	{
		$type = $entry ? $entry->type : null;
		
		// Use the out route for this type. If there is no type specific route use the fall back
		// route if possible.
		if ( !is_null($type) and array_key_exists($type, self::$out_routes) )
			$route = self::$out_routes[$type];
		elseif ( array_key_exists(null, self::$out_routes) )
			$route = self::$out_routes[null];
		
		return is_callable($route) ? $route($path, $entry) : null;
	}
	
	/**
	 * Prepares this entry for caching by doing all expensive calculations
	 * and store the results in the respective properties.
	 */
	function prepare_for_caching()
	{
		$this->content = self::process_content($this->raw_content, $this->processors_as_list, $this);
	}
	
	/**
	 * Sends the specified `$content` though the processors specified in the `$processor_list`
	 * argument. Each processor is called the the output of the previous processor and the
	 * context entry as arguments. A processor might use the context entry to look for headers
	 * that control the details of a processor.
	 * 
	 * Returns the processed content.
	 */
	static function process_content($content, $processor_list, $context_entry = null)
	{
		foreach($processor_list as $processor_name)
		{
			$processor = @self::$processors[$processor_name];
			if ( is_callable($processor) )
				$content = $processor($content, $context_entry);
		}
		
		return $content;
	}
	
	
	//
	// Header and property access and conversation
	//
	
	function __get($property_name)
	{
		// When the `content` property is not generated yet do it, otherwise return the old value
		if ($property_name == 'content')
			if ( is_null($this->content) )
				return ( $this->content = self::process_content($this->raw_content, $this->processors_as_list, $this) );
			else
				return $this->content;
		
		// Make all private properties readable. Yes, it's strange and sounds stupid but it is what
		// we actually want here. All private properties contain stuff the user is interested in but
		// should not change.
		if ( property_exists($this, $property_name) )
			return $this->$property_name;
		
		// If the user wants a header in a special format parse or convert it.
		if ( preg_match('/^(?<name>.+)_as_(?<format>list|time|array)$/i', $property_name, $matches) )
		{
			if ($matches['format'] == 'list')
				return self::parse_list_header(@$this->headers[$matches['name']]);
			if ($matches['format'] == 'time')
				return self::parse_time_header(@$this->headers[$matches['name']]);
			if ($matches['format'] == 'array')
				if ( is_array(@$this->headers[$matches['name']]) )
					return @$this->headers[$matches['name']];
				else
					return array(@$this->headers[$matches['name']]);
		}
		
		// Every header should be available as a property. Therefore we try to return a header with
		// the name of the requested property.
		return @$this->headers[$property_name];
	}
	
	/**
	 * Parses header as a list and returns the elements as an array.
	 * If the input parameter is invalid an empty array is returned.
	 */
	static function parse_list_header($header_content)
	{
		if ($header_content)
		{
			$elements = explode(',', $header_content);
			return array_map('trim', $elements);
		}
		
		return array();
	}
	
	/**
	 * Parses the specified header content as a date and returns its
	 * the timestamp. If the header isn't a valid date false is returned.
	 */
	static function parse_time_header($header_content)
	{
		$matched = preg_match('/(\d{4})(-(\d{2})(-(\d{2})(\s+(\d{2}):(\d{2})(:(\d{2}))?)?)?)?/i', $header_content, $matches);
		if (!$matched)
			return false;
		
		@list($year, $month, $day, $hour, $minute, $second) = array($matches[1], $matches[3], $matches[5], $matches[7], $matches[8], $matches[10]);
		
		// Set default values to 1 for month and day (we usually
		// mean that when we omit that part of the date).
		if ( empty($month) )
			$month = 1;
		if ( empty($day) )
			$day = 1;
		
		return mktime($hour, $minute, $second, $month, $day, $year);
	}
	
	/**
	 * Converts the specified name into a better readable form that
	 * can be used in "pretty" URLs.
	 */
	static function parameterize($name)
	{
		return trim( preg_replace('/[^\w\däüöß+]+/', '-', strtolower($name)), '-' );
	}
}

?>
